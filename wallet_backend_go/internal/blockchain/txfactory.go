package blockchain

// txfactory.go contains helper functions to construct transactions
// from wallets and UTXO sets. It includes conversion utilities
// for keys and curves used by the API layer.

import (
    "crypto/ecdsa"
    "crypto/elliptic"
    "errors"
    "fmt"
    "math/big"
    "encoding/hex"
)

// GetDefaultCurve returns the elliptic curve used throughout the
// application. Exposed for API code needing curve information.
func GetDefaultCurve() elliptic.Curve {
    return elliptic.P256()
}

// BigIntToPrivateKey reconstructs an ECDSA private key from the
// provided D value bytes and curve. It computes the public key by
// performing a scalar multiplication of the curve's base point. If
// dBytes is zero or invalid, a zero value key is returned.
func BigIntToPrivateKey(dBytes []byte, curve elliptic.Curve) ecdsa.PrivateKey {
    d := new(big.Int).SetBytes(dBytes)
    x, y := curve.ScalarBaseMult(d.Bytes())
    return ecdsa.PrivateKey{PublicKey: ecdsa.PublicKey{Curve: curve, X: x, Y: y}, D: d}
}

// NewUTXOTransaction creates and signs a new transaction spending
// existing unspent outputs and sending value to the recipient. It
// accepts the private key, recipient address, amount, reference to
// the blockchain, the spendable outputs map generated by
// UTXO.FindSpendableOutputs and the public key hash of the sender. It
// returns a signed transaction or an error if something goes wrong.
func NewUTXOTransaction(privKey ecdsa.PrivateKey, to string, amount int, bc *Blockchain, spendable map[string][]int, fromPubKeyHash []byte, accumulated int) (*Transaction, error) {
    if amount > accumulated {
        return nil, errors.New("not enough funds")
    }
    var inputs []TxInput
    var outputs []TxOutput
    // gather inputs
    for txidStr, outIdxs := range spendable {
        txIDBytes, err := hex.DecodeString(txidStr)
        if err != nil {
            return nil, fmt.Errorf("invalid txid: %v", err)
        }
        for _, outIdx := range outIdxs {
            input := TxInput{Txid: txIDBytes, Vout: outIdx, Signature: nil, PubKey: nil}
            inputs = append(inputs, input)
        }
    }
    // create output to recipient
    toBytes, err := hex.DecodeString(to)
    if err != nil {
        return nil, fmt.Errorf("invalid recipient address: %v", err)
    }
    outputs = append(outputs, TxOutput{Value: amount, PubKeyHash: toBytes})
    // add change back to sender
    if accumulated > amount {
        outputs = append(outputs, TxOutput{Value: accumulated - amount, PubKeyHash: fromPubKeyHash})
    }
    tx := &Transaction{ID: nil, Vin: inputs, Vout: outputs}
    tx.SetID()
    // sign transaction
    prevTXs := make(map[string]Transaction)
    for txidStr := range spendable {
        txIDBytes, _ := hex.DecodeString(txidStr)
        prevTx, err := bc.FindTransaction(txIDBytes)
        if err != nil {
            return nil, fmt.Errorf("referenced transaction not found: %v", err)
        }
        prevTXs[txidStr] = prevTx
    }
    if err := tx.Sign(privKey, prevTXs); err != nil {
        return nil, fmt.Errorf("signing failed: %v", err)
    }
    return tx, nil
}